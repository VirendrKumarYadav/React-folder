{"ast":null,"code":"import { useRef, useState, useEffect } from 'react';\nimport { toast } from 'react-toastify';\nfunction useNotificationCenter(params) {\n  if (params === void 0) {\n    params = {};\n  }\n  const sortFn = useRef(params.sort || defaultSort);\n  const filterFn = useRef(params.filter || null);\n  const [notifications, setNotifications] = useState(() => {\n    if (params.data) {\n      return filterFn.current ? params.data.filter(filterFn.current).sort(sortFn.current) : [...params.data].sort(sortFn.current);\n    }\n    return [];\n  }); // used to method to be used inside effect without having stale `notifications`\n\n  const notificationsRef = useRef(notifications);\n  useEffect(() => {\n    notificationsRef.current = notifications;\n  }, [notifications]);\n  useEffect(() => {\n    return toast.onChange(toast => {\n      if (toast.status === 'added' || toast.status === 'updated') {\n        const newItem = decorate(toast);\n        if (filterFn.current && !filterFn.current(newItem)) return;\n        setNotifications(prev => {\n          let nextState = [];\n          const updateIdx = prev.findIndex(v => v.id === newItem.id);\n          if (updateIdx !== -1) {\n            nextState = prev.slice();\n            Object.assign(nextState[updateIdx], newItem, {\n              createdAt: Date.now()\n            });\n          } else if (prev.length === 0) {\n            nextState = [newItem];\n          } else {\n            nextState = [newItem, ...prev];\n          }\n          return nextState.sort(sortFn.current);\n        });\n      }\n    });\n  }, []);\n  const remove = id => {\n    setNotifications(prev => prev.filter(Array.isArray(id) ? v => !id.includes(v.id) : v => v.id !== id));\n  };\n  const clear = () => {\n    setNotifications([]);\n  };\n  const markAllAsRead = function (read) {\n    if (read === void 0) {\n      read = true;\n    }\n    setNotifications(prev => prev.map(v => {\n      v.read = read;\n      return v;\n    }));\n  };\n  const markAsRead = function (id, read) {\n    if (read === void 0) {\n      read = true;\n    }\n    let map = v => {\n      if (v.id === id) v.read = read;\n      return v;\n    };\n    if (Array.isArray(id)) {\n      map = v => {\n        if (id.includes(v.id)) v.read = read;\n        return v;\n      };\n    }\n    setNotifications(prev => prev.map(map));\n  };\n  const find = id => {\n    return Array.isArray(id) ? notificationsRef.current.filter(v => id.includes(v.id)) : notificationsRef.current.find(v => v.id === id);\n  };\n  const add = item => {\n    if (notificationsRef.current.find(v => v.id === item.id)) return null;\n    const newItem = decorate(item);\n    setNotifications(prev => [...prev, newItem].sort(sortFn.current));\n    return newItem.id;\n  };\n  const update = (id, item) => {\n    const index = notificationsRef.current.findIndex(v => v.id === id);\n    if (index !== -1) {\n      setNotifications(prev => {\n        const nextState = [...prev];\n        Object.assign(nextState[index], item, {\n          createdAt: item.createdAt || Date.now()\n        });\n        return nextState.sort(sortFn.current);\n      });\n      return item.id;\n    }\n    return null;\n  };\n  const sort = compareFn => {\n    sortFn.current = compareFn;\n    setNotifications(prev => prev.slice().sort(compareFn));\n  };\n  return {\n    notifications,\n    clear,\n    markAllAsRead,\n    markAsRead,\n    add,\n    update,\n    remove,\n    // @ts-ignore fixme: overloading issue\n    find,\n    sort,\n    get unreadCount() {\n      return notifications.reduce((prev, cur) => !cur.read ? prev + 1 : prev, 0);\n    }\n  };\n}\nfunction decorate(item) {\n  if (item.id == null) item.id = Date.now().toString(36).substring(2, 9);\n  if (!item.createdAt) item.createdAt = Date.now();\n  if (item.read == null) item.read = false;\n  return item;\n} // newest to oldest\n\nfunction defaultSort(l, r) {\n  return r.createdAt - l.createdAt;\n}\nexport { useNotificationCenter };","map":{"version":3,"names":["useNotificationCenter","params","sortFn","useRef","sort","defaultSort","filterFn","filter","notifications","setNotifications","useState","data","current","notificationsRef","useEffect","toast","onChange","status","newItem","decorate","prev","nextState","updateIdx","findIndex","v","id","slice","Object","assign","createdAt","Date","now","length","remove","Array","isArray","includes","clear","markAllAsRead","read","map","markAsRead","find","add","item","update","index","compareFn","unreadCount","reduce","cur","toString","substring","l","r"],"sources":["C:\\Users\\softe\\OneDrive\\Desktop\\React\\Toaster\\node_modules\\src\\addons\\use-notification-center\\useNotificationCenter.ts"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\nimport { toast, ToastItem, Id } from 'react-toastify';\n\ntype Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport interface NotificationCenterItem<Data = {}>\n  extends Optional<ToastItem<Data>, 'content' | 'data'> {\n  read: boolean;\n  createdAt: number;\n}\n\nexport type SortFn<Data> = (\n  l: NotificationCenterItem<Data>,\n  r: NotificationCenterItem<Data>\n) => number;\n\nexport type FilterFn<Data = {}> = (\n  item: NotificationCenterItem<Data>\n) => boolean;\n\nexport interface UseNotificationCenterParams<Data = {}> {\n  /**\n   * initial data to rehydrate the notification center\n   */\n  data?: NotificationCenterItem<Data>[];\n\n  /**\n   * By default, the notifications are sorted from the newest to the oldest using\n   * the `createdAt` field. Use this to provide your own sort function\n   *\n   * Usage:\n   * ```\n   * // old notifications first\n   * useNotificationCenter({\n   *   sort: ((l, r) => l.createdAt - r.createdAt)\n   * })\n   * ```\n   */\n  sort?: SortFn<Data>;\n\n  /**\n   * Keep the toast that meets the condition specified in the callback function.\n   *\n   * Usage:\n   * ```\n   * // keep only the toasts when hidden is set to false\n   * useNotificationCenter({\n   *   filter: item => item.data.hidden === false\n   * })\n   * ```\n   */\n  filter?: FilterFn<Data>;\n}\n\nexport interface UseNotificationCenter<Data> {\n  /**\n   * Contains all the notifications\n   */\n  notifications: NotificationCenterItem<Data>[];\n\n  /**\n   * Clear all notifications\n   */\n  clear(): void;\n\n  /**\n   * Mark all notification as read\n   */\n  markAllAsRead(): void;\n\n  /**\n   * Mark all notification as read or not.\n   *\n   * Usage:\n   * ```\n   * markAllAsRead(false) // mark all notification as not read\n   *\n   * markAllAsRead(true) // same as calling markAllAsRead()\n   * ```\n   */\n  markAllAsRead(read?: boolean): void;\n\n  /**\n   * Mark one or more notifications as read.\n   *\n   * Usage:\n   * ```\n   * markAsRead(\"anId\")\n   * markAsRead([\"a\",\"list\", \"of\", \"id\"])\n   * ```\n   */\n  markAsRead(id: Id | Id[]): void;\n\n  /**\n   * Mark one or more notifications as read.The second parameter let you mark the notificaiton as read or not.\n   *\n   * Usage:\n   * ```\n   * markAsRead(\"anId\", false)\n   * markAsRead([\"a\",\"list\", \"of\", \"id\"], false)\n   *\n   * markAsRead(\"anId\", true) // same as markAsRead(\"anId\")\n   * ```\n   */\n  markAsRead(id: Id | Id[], read?: boolean): void;\n\n  /**\n   * Remove one or more notifications\n   *\n   * Usage:\n   * ```\n   * remove(\"anId\")\n   * remove([\"a\",\"list\", \"of\", \"id\"])\n   * ```\n   */\n  remove(id: Id | Id[]): void;\n\n  /**\n   * Push a notification to the notification center.\n   * Returns null when an item with the given id already exists\n   *\n   * Usage:\n   * ```\n   * const id = add({id: \"id\", content: \"test\", data: { foo: \"hello\" } })\n   *\n   * // Return the id of the notificaiton, generate one if none provided\n   * const id = add({ data: {title: \"a title\", text: \"some text\"} })\n   * ```\n   */\n  add(item: Partial<NotificationCenterItem<Data>>): Id | null;\n\n  /**\n   * Update the notification that match the id\n   * Returns null when no matching notification found\n   *\n   * Usage:\n   * ```\n   * const id = update(\"anId\",  {content: \"test\", data: { foo: \"hello\" } })\n   *\n   * // It's also possible to update the id\n   * const id = update(\"anId\"m { id:\"anotherOne\", data: {title: \"a title\", text: \"some text\"} })\n   * ```\n   */\n  update(id: Id, item: Partial<NotificationCenterItem<Data>>): Id | null;\n\n  /**\n   * Retrive one or more notifications\n   *\n   * Usage:\n   * ```\n   * find(\"anId\")\n   * find([\"a\",\"list\", \"of\", \"id\"])\n   * ```\n   */\n  find(id: Id): NotificationCenterItem<Data> | undefined;\n\n  /**\n   * Retrive one or more notifications\n   *\n   * Usage:\n   * ```\n   * find(\"anId\")\n   * find([\"a\",\"list\", \"of\", \"id\"])\n   * ```\n   */\n  find(id: Id[]): NotificationCenterItem<Data>[] | undefined;\n\n  /**\n   * Retrieve the count for unread notifications\n   */\n  unreadCount: number;\n\n  /**\n   * Sort notifications using the newly provided function\n   *\n   * Usage:\n   * ```\n   * // old notifications first\n   * sort((l, r) => l.createdAt - r.createdAt)\n   * ```\n   */\n  sort(sort: SortFn<Data>): void;\n}\n\nexport function useNotificationCenter<Data = {}>(\n  params: UseNotificationCenterParams<Data> = {}\n): UseNotificationCenter<Data> {\n  const sortFn = useRef(params.sort || defaultSort);\n  const filterFn = useRef(params.filter || null);\n  const [notifications, setNotifications] = useState<\n    NotificationCenterItem<Data>[]\n  >(() => {\n    if (params.data) {\n      return filterFn.current\n        ? params.data.filter(filterFn.current).sort(sortFn.current)\n        : [...params.data].sort(sortFn.current);\n    }\n    return [];\n  });\n  // used to method to be used inside effect without having stale `notifications`\n  const notificationsRef = useRef(notifications);\n\n  useEffect(() => {\n    notificationsRef.current = notifications;\n  }, [notifications]);\n\n  useEffect(() => {\n    return toast.onChange(toast => {\n      if (toast.status === 'added' || toast.status === 'updated') {\n        const newItem = decorate(toast as NotificationCenterItem<Data>);\n        if (filterFn.current && !filterFn.current(newItem)) return;\n\n        setNotifications(prev => {\n          let nextState: NotificationCenterItem<Data>[] = [];\n          const updateIdx = prev.findIndex(v => v.id === newItem.id);\n\n          if (updateIdx !== -1) {\n            nextState = prev.slice();\n            Object.assign(nextState[updateIdx], newItem, {\n              createdAt: Date.now()\n            });\n          } else if (prev.length === 0) {\n            nextState = [newItem];\n          } else {\n            nextState = [newItem, ...prev];\n          }\n          return nextState.sort(sortFn.current);\n        });\n      }\n    });\n  }, []);\n\n  const remove = (id: Id | Id[]) => {\n    setNotifications(prev =>\n      prev.filter(\n        Array.isArray(id) ? v => !id.includes(v.id) : v => v.id !== id\n      )\n    );\n  };\n\n  const clear = () => {\n    setNotifications([]);\n  };\n\n  const markAllAsRead = (read = true) => {\n    setNotifications(prev =>\n      prev.map(v => {\n        v.read = read;\n        return v;\n      })\n    );\n  };\n\n  const markAsRead = (id: Id | Id[], read = true) => {\n    let map = (v: NotificationCenterItem<Data>) => {\n      if (v.id === id) v.read = read;\n      return v;\n    };\n\n    if (Array.isArray(id)) {\n      map = v => {\n        if (id.includes(v.id)) v.read = read;\n        return v;\n      };\n    }\n\n    setNotifications(prev => prev.map(map));\n  };\n\n  const find = (id: Id | Id[]) => {\n    return Array.isArray(id)\n      ? notificationsRef.current.filter(v => id.includes(v.id))\n      : notificationsRef.current.find(v => v.id === id);\n  };\n\n  const add = (item: Partial<NotificationCenterItem<Data>>) => {\n    if (notificationsRef.current.find(v => v.id === item.id)) return null;\n\n    const newItem = decorate(item);\n\n    setNotifications(prev => [...prev, newItem].sort(sortFn.current));\n\n    return newItem.id;\n  };\n\n  const update = (id: Id, item: Partial<NotificationCenterItem<Data>>) => {\n    const index = notificationsRef.current.findIndex(v => v.id === id);\n\n    if (index !== -1) {\n      setNotifications(prev => {\n        const nextState = [...prev];\n        Object.assign(nextState[index], item, {\n          createdAt: item.createdAt || Date.now()\n        });\n\n        return nextState.sort(sortFn.current);\n      });\n\n      return item.id as Id;\n    }\n\n    return null;\n  };\n\n  const sort = (compareFn: SortFn<Data>) => {\n    sortFn.current = compareFn;\n    setNotifications(prev => prev.slice().sort(compareFn));\n  };\n\n  return {\n    notifications,\n    clear,\n    markAllAsRead,\n    markAsRead,\n    add,\n    update,\n    remove,\n    // @ts-ignore fixme: overloading issue\n    find,\n    sort,\n    get unreadCount() {\n      return notifications.reduce(\n        (prev, cur) => (!cur.read ? prev + 1 : prev),\n        0\n      );\n    }\n  };\n}\n\nfunction decorate<Data>(\n  item: NotificationCenterItem<Data> | Partial<NotificationCenterItem<Data>>\n) {\n  if (item.id == null) item.id = Date.now().toString(36).substring(2, 9);\n  if (!item.createdAt) item.createdAt = Date.now();\n  if (item.read == null) item.read = false;\n  return item as NotificationCenterItem<Data>;\n}\n\n// newest to oldest\nfunction defaultSort<Data>(\n  l: NotificationCenterItem<Data>,\n  r: NotificationCenterItem<Data>\n) {\n  return r.createdAt - l.createdAt;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}